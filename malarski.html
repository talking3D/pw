<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="UTF-8" />
    <title>Wirtualna Kamera z algorytmem malarskim</title>
    <style>
      canvas {
        border: 1px solid black;
      }
    </style>
  </head>
  <body>
    <canvas id="miasto" width="800" height="600"></canvas>
    <script>
      /***************** Funkcje pomocnicze *****************/
      // Mnożenie macierzy 3x3
      function multiplyMatrix3(a, b) {
        let result = [];
        for (let i = 0; i < 3; i++) {
          result[i] = [];
          for (let j = 0; j < 3; j++) {
            result[i][j] = 0;
            for (let k = 0; k < 3; k++) {
              result[i][j] += a[i][k] * b[k][j];
            }
          }
        }
        return result;
      }

      // Transpozycja macierzy 3x3
      function transposeMatrix3(m) {
        return [
          [m[0][0], m[1][0], m[2][0]],
          [m[0][1], m[1][1], m[2][1]],
          [m[0][2], m[1][2], m[2][2]],
        ];
      }

      // Mnożenie macierzy 3x3 przez wektor (3x1)
      function multiplyMatrixVector(R, v) {
        return {
          x: R[0][0] * v.x + R[0][1] * v.y + R[0][2] * v.z,
          y: R[1][0] * v.x + R[1][1] * v.y + R[1][2] * v.z,
          z: R[2][0] * v.x + R[2][1] * v.y + R[2][2] * v.z,
        };
      }

      /***************** Parametry kamery *****************/
      let camera = {
        // Pozycja kamery w przestrzeni świata
        pos: { x: 0, y: 0, z: -50 },
        // Rotacje kamery (w radianach)
        pitch: 0, // obrót wokół osi X
        yaw: 0, // obrót wokół osi Y
        roll: 0, // obrót wokół osi Z
        // Ogniskowa (zoom)
        focalLength: 500,
      };

      /***************** Macierz rotacji kamery *****************/
      function getCameraRotationMatrix(camera) {
        let cosYaw = Math.cos(camera.yaw),
          sinYaw = Math.sin(camera.yaw);
        let cosPitch = Math.cos(camera.pitch),
          sinPitch = Math.sin(camera.pitch);
        let cosRoll = Math.cos(camera.roll),
          sinRoll = Math.sin(camera.roll);

        // Rotacja wokół osi Y (yaw)
        let R_yaw = [
          [cosYaw, 0, sinYaw],
          [0, 1, 0],
          [-sinYaw, 0, cosYaw],
        ];
        // Rotacja wokół osi X (pitch)
        let R_pitch = [
          [1, 0, 0],
          [0, cosPitch, -sinPitch],
          [0, sinPitch, cosPitch],
        ];
        // Rotacja wokół osi Z (roll)
        let R_roll = [
          [cosRoll, -sinRoll, 0],
          [sinRoll, cosRoll, 0],
          [0, 0, 1],
        ];

        // Łączymy macierze – kolejność: yaw, pitch, roll
        let R_temp = multiplyMatrix3(R_pitch, R_yaw);
        let R_total = multiplyMatrix3(R_roll, R_temp);
        return R_total;
      }

      /***************** Transformacja punktów ze świata do układu kamery *****************/
      function getViewTransform(camera) {
        let R_total = getCameraRotationMatrix(camera);
        let R_inv = transposeMatrix3(R_total);
        return function (worldPoint) {
          let dx = worldPoint.x - camera.pos.x;
          let dy = worldPoint.y - camera.pos.y;
          let dz = worldPoint.z - camera.pos.z;
          return {
            x: R_inv[0][0] * dx + R_inv[0][1] * dy + R_inv[0][2] * dz,
            y: R_inv[1][0] * dx + R_inv[1][1] * dy + R_inv[1][2] * dz,
            z: R_inv[2][0] * dx + R_inv[2][1] * dy + R_inv[2][2] * dz,
          };
        };
      }

      /***************** Rzutowanie perspektywiczne i konwersja do układu Canvas *****************/
      function project(point, camera) {
        if (point.z <= 0) return null;
        return {
          x: (camera.focalLength * point.x) / point.z,
          y: (camera.focalLength * point.y) / point.z,
        };
      }

      function toScreen(point, canvas) {
        return {
          x: canvas.width / 2 + point.x,
          y: canvas.height / 2 - point.y,
        };
      }

      /***************** Definicja sceny – obiekty wielościenne *****************/
      let scenePolygons = [];

      // Funkcja dodająca dowolny wielościan (lista punktów) do sceny
      function addPolygon(vertices, color) {
        scenePolygons.push({ vertices: vertices, color: color });
      }

      // Dodanie trójkąta (wierzchołki podane w układzie świata)
      function addTriangle(p1, p2, p3, color) {
        addPolygon([p1, p2, p3], color);
      }

      // Dodanie ośmiokąta – wykorzystujemy funkcję addCircle z segmentami = 8
      function addOctagon(cx, cy, cz, radius, color) {
        addCircle(cx, cy, cz, radius, 8, color);
      }

      // Dodanie „koła” – aproksymacja wielokątem o zadanej liczbie segmentów
      function addCircle(cx, cy, cz, radius, segments, color) {
        let vertices = [];
        for (let i = 0; i < segments; i++) {
          let theta = (i / segments) * 2 * Math.PI;
          vertices.push({
            x: cx + radius * Math.cos(theta),
            y: cy + radius * Math.sin(theta),
            z: cz,
          });
        }
        addPolygon(vertices, color);
      }

      // Przykładowe obiekty:
      // Trójkąt – umieszczony w pewnej odległości
      addTriangle(
        { x: -40, y: -20, z: 150 },
        { x: 0, y: 40, z: 150 },
        { x: 40, y: -20, z: 150 },
        "rgba(255, 0, 0, 0.7)"
      );
      // Ośmiokąt – umieszczony dalej (bardziej oddalony, więc powinien być rysowany najpierw)
      addOctagon(-60, 0, 220, 30, "rgba(0, 255, 0, 0.7)");
      // Koło – aproksymowane wielokątem, bliżej kamery
      addCircle(50, -10, 100, 25, 30, "rgba(0, 0, 255, 0.7)");

      /***************** Rysowanie sceny z algorytmem malarskim *****************/
      function drawScene() {
        let canvas = document.getElementById("miasto");
        let ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        let transform = getViewTransform(camera);
        let polygonsToDraw = [];

        // Przekształć wszystkie obiekty i oblicz ich średnią głębokość
        for (let poly of scenePolygons) {
          let transformed = [];
          let sumZ = 0;
          let visible = true;
          for (let v of poly.vertices) {
            let tv = transform(v);
            // Jeśli choć jeden punkt jest za kamerą, pomijamy (tu brak clipowania)
            if (tv.z <= 0) {
              visible = false;
              break;
            }
            sumZ += tv.z;
            transformed.push(tv);
          }
          if (!visible) continue;
          let avgZ = sumZ / poly.vertices.length;
          polygonsToDraw.push({ transformed, color: poly.color, avgZ });
        }

        // Sortowanie – najpierw rysujemy obiekty dalsze
        polygonsToDraw.sort((a, b) => b.avgZ - a.avgZ);

        // Rysowanie posortowanych obiektów
        for (let poly of polygonsToDraw) {
          ctx.beginPath();
          for (let i = 0; i < poly.transformed.length; i++) {
            let proj = project(poly.transformed[i], camera);
            if (!proj) continue;
            let screenPt = toScreen(proj, canvas);
            if (i === 0) {
              ctx.moveTo(screenPt.x, screenPt.y);
            } else {
              ctx.lineTo(screenPt.x, screenPt.y);
            }
          }
          ctx.closePath();
          ctx.fillStyle = poly.color;
          ctx.fill();
          ctx.strokeStyle = "black";
          ctx.stroke();
        }
      }

      /***************** Obsługa klawiatury *****************/
      document.addEventListener("keydown", function (e) {
        const moveStep = 5;
        const angleStep = (Math.PI / 180) * 5; // 5 stopni
        let localMove = { x: 0, y: 0, z: 0 };

        switch (e.key) {
          // Translacja – ruchy w układzie kamery
          case "w": // do przodu (lokalnie wzdłuż osi Z)
            localMove.z = moveStep;
            break;
          case "s": // do tyłu
            localMove.z = -moveStep;
            break;
          case "a": // w lewo (lokalnie ujemna oś X)
            localMove.x = -moveStep;
            break;
          case "d": // w prawo
            localMove.x = moveStep;
            break;
          case "q": // w górę (lokalnie oś Y dodatnia)
            localMove.y = moveStep;
            break;
          case "e": // w dół
            localMove.y = -moveStep;
            break;
          // Obrót kamery – modyfikujemy kąty
          case "ArrowUp":
            camera.pitch += angleStep;
            break;
          case "ArrowDown":
            camera.pitch -= angleStep;
            break;
          case "ArrowLeft":
            camera.yaw += angleStep;
            break;
          case "ArrowRight":
            camera.yaw -= angleStep;
            break;
          case "r":
            camera.roll += angleStep;
            break;
          case "f":
            camera.roll -= angleStep;
            break;
          // Zoom – zmiana ogniskowej
          case "z":
            camera.focalLength += 20;
            break;
          case "x":
            camera.focalLength -= 20;
            if (camera.focalLength < 20) camera.focalLength = 20;
            break;
        }

        // Translacja – przekształcamy ruch z układu kamery do świata
        if (localMove.x !== 0 || localMove.y !== 0 || localMove.z !== 0) {
          let R_total = getCameraRotationMatrix(camera);
          let worldMove = multiplyMatrixVector(R_total, localMove);
          camera.pos.x += worldMove.x;
          camera.pos.y += worldMove.y;
          camera.pos.z += worldMove.z;
        }
        drawScene();
      });

      /***************** Inicjalizacja *****************/
      drawScene();
    </script>
  </body>
</html>
